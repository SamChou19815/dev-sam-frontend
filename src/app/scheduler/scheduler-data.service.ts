import { Injectable } from '@angular/core';
import { GoogleUser } from '../shared/google-user';
import { GoogleUserService } from '../shared/google-user.service';
import { dummySchedulerProcessedData, SchedulerProcessData } from './scheduler-data';
import { SchedulerEvent, SchedulerEventType, SchedulerEventWithIndex } from './scheduler-event';
import { SchedulerNetworkService } from './scheduler-network.service';
import { SchedulerProject, SchedulerProjectWithIndex } from './scheduler-project';
import { SchedulerTaggedInterval } from './scheduler-tagged-interval';

@Injectable({
  providedIn: 'root'
})
export class SchedulerDataService {

  /**
   * All scheduler data submitted by the user.
   */
  private _schedulerData: SchedulerProcessData = dummySchedulerProcessedData;
  /**
   * All the personal auto schedule generated by the system.
   */
  private _personalAutoSchedule?: SchedulerTaggedInterval[];

  constructor(private googleUserService: GoogleUserService,
              private networkService: SchedulerNetworkService) {
  }

  /*
   * --------------------------------------------------------------------------------
   * Part 0: Projects & Events
   * --------------------------------------------------------------------------------
   */

  /**
   * Initialize the scheduler app with loaded data.
   *
   * @returns {Promise<void>} promise when done.
   */
  async initializedSchedulerApp(): Promise<void> {
    if (!this._schedulerData.isNotInitialized) {
      return;
    }
    this.networkService.firebaseAuthToken = await this.googleUserService.afterSignedIn();
    const rawData = await this.networkService.loadData();
    this._schedulerData = <SchedulerProcessData>{
      projects: rawData.projects.map(p => new SchedulerProject(p)),
      events: SchedulerEvent.classify(rawData.events.map(e => new SchedulerEvent(e))),
      isNotInitialized: false
    };
  }

  /**
   * Returns the scheduler data. If it's not initialized, it will returns an empty instance.
   *
   * @returns {SchedulerData} the scheduler data
   */
  get schedulerData(): SchedulerProcessData {
    return this._schedulerData;
  }

  /*
   * --------------------------------------------------------------------------------
   * Part 1: Projects
   * --------------------------------------------------------------------------------
   */

  /**
   * Edit a scheduler project.
   *
   * @param {SchedulerProject} editedProject the edited and verified new project.
   * @param {number} originalIndex the original index.
   * @returns {Promise<void>} promise when done.
   */
  async editProject(editedProject: SchedulerProject, originalIndex?: number): Promise<void> {
    const key = await this.networkService.editProject(editedProject);
    const newProject = new SchedulerProject(<SchedulerProject>{ ...editedProject, key: key });
    const projects = this._schedulerData.projects;
    // remove old
    if (originalIndex != null) {
      projects.splice(originalIndex, 1);
    }
    projects.push(newProject);
    projects.sort(SchedulerProject.compare);
    this.invalidatePersonalAutoSchedule();
  }

  /**
   * Delete a scheduler project.
   *
   * @param {SchedulerProject} project project to delete.
   * @param {number} index index of the event.
   * @returns {Promise<void>} promise when done.
   */
  async deleteProject({ project, index }: SchedulerProjectWithIndex) {
    if (project.key == null) {
      return;
    }
    await this.networkService.deleteRecord(project.key, 'project');
    this._schedulerData.projects.splice(index, 1);
    this.invalidatePersonalAutoSchedule();
  }

  /**
   * Mark project as completed or not.
   *
   * @param {SchedulerProject} project the project to mark.
   * @param {number} index index of the project.
   * @param {boolean} isCompleted whether the project should be marked as completed.
   */
  async markProjectAs(
    { project, index }: SchedulerProjectWithIndex, isCompleted: boolean
  ): Promise<void> {
    if (project.key == null) {
      return;
    }
    await this.networkService.markProjectAs(isCompleted, project.key);
    const newProject = new SchedulerProject(<SchedulerProject>{
      ...project, isCompleted: isCompleted
    });
    this._schedulerData.projects.splice(index, 1, newProject);
    this.invalidatePersonalAutoSchedule();
  }

  /*
   * --------------------------------------------------------------------------------
   * Part 2: Events
   * --------------------------------------------------------------------------------
   */

  /**
   * Edit a scheduler event.
   *
   * @param {SchedulerEvent} editedEvent the edited and verified new event.
   * @param {number} originalIndex the original index.
   * @returns {Promise<void>} promise when done.
   */
  async editEvent(editedEvent: SchedulerEvent, originalIndex?: number): Promise<void> {
    const key = await this.networkService.editEvent(editedEvent);
    const newEvent = new SchedulerEvent(<SchedulerEvent>{ ...editedEvent, key: key });
    const events = this._schedulerData.events;
    // remove old
    if (originalIndex != null) {
      switch (newEvent.type) {
        case SchedulerEventType.ONE_TIME:
          events.oneTimeEvents.splice(originalIndex, 1);
          break;
        case SchedulerEventType.WEEKLY:
          events.weeklyEvents.splice(originalIndex, 1);
          break;
      }
    }
    switch (newEvent.type) {
      case SchedulerEventType.ONE_TIME:
        events.oneTimeEvents.push(newEvent);
        events.oneTimeEvents.sort((a, b) => a.repeatConfig - b.repeatConfig);
        break;
      case SchedulerEventType.WEEKLY:
        events.weeklyEvents.push(newEvent);
        events.weeklyEvents.sort((a, b) => b.repeatConfig - a.repeatConfig);
        break;
    }
    this.invalidatePersonalAutoSchedule();
  }

  /**
   * Delete a scheduler event.
   *
   * @param {SchedulerProject} event event to delete.
   * @param {number} index index of the event.
   * @returns {Promise<void>} promise when done.
   */
  async deleteEvent({ event, index }: SchedulerEventWithIndex) {
    if (event.key == null) {
      return;
    }
    await this.networkService.deleteRecord(event.key, 'event');
    switch (event.type) {
      case SchedulerEventType.ONE_TIME:
        this._schedulerData.events.oneTimeEvents.splice(index, 1);
        break;
      case SchedulerEventType.WEEKLY:
        this._schedulerData.events.weeklyEvents.splice(index, 1);
        break;
    }
    this.invalidatePersonalAutoSchedule();
  }

  /*
   * --------------------------------------------------------------------------------
   * Part 3: Auto Scheduling
   * --------------------------------------------------------------------------------
   */

  /**
   * Initialize the data for auto schedule.
   *
   * @returns {Promise<void>} the promise when done.
   */
  async initializePersonalAutoSchedule(): Promise<void> {
    if (this._personalAutoSchedule != null) {
      return;
    }
    this.networkService.firebaseAuthToken = await this.googleUserService.afterSignedIn();
    this._personalAutoSchedule = await this.networkService.getAutoScheduling();
  }

  /**
   * Returns a list of personal auto schedule.
   *
   * @returns {SchedulerTaggedInterval[]} a list of personal auto schedule.
   */
  get personalAutoSchedule(): SchedulerTaggedInterval[] {
    return this._personalAutoSchedule ? this._personalAutoSchedule : [];
  }

  /**
   * Returns the promise of auto schedule with friends, which always resolves.
   *
   * @param {GoogleUser} friend a friend, which must exist.
   * @returns {Promise<SchedulerTaggedInterval[]>} the promise of auto schedule with friends, which
   * always resolves.
   */
  async asyncGetAutoScheduleWithFriend(friend: GoogleUser): Promise<SchedulerTaggedInterval[]> {
    return this.networkService.getAutoScheduling(friend.key);
  }

  /**
   * Invalidate the current personal auto schedule.
   */
  private invalidatePersonalAutoSchedule(): void {
    this._personalAutoSchedule = undefined;
  }

}
